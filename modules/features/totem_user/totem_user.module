<?php
/**
 * @file
 * totem_user.module
 */

require_once 'totem_user.features.inc';
require_once 'includes/totem_user.theme.inc';
require_once 'includes/totem_user.form.inc';
require_once 'includes/totem_user.block.inc';

// Private helper functions.
/**
 * Get a list of all uid values that have been granted
 * "totem_user_node_manager" perms per input community node.
 */
function _totem_user_get_managers(&$node, $reset = FALSE) {

  // Cache these values since this function is potentially called on a
  // per-user basis (e.g. /node/nid/members).
  $key = __FUNCTION__ . "_{$node->nid}";
  $gid = &drupal_static($key);

  if (empty($gid) || $reset) {
    // Get grants + alterations.
    $grants = module_invoke_all('node_access_records', $node);
    drupal_alter('node_access_records', $grants, $node);
    $gid = array();
    foreach ($grants as $g) {
      if ($g['realm'] == 'totem_user_node_manager') {
        $gid[] = $g['gid'];
      }
    }
  }

  return $gid;
}
/**
 * Get a list of all uid values that have been granted
 * "totem_user_node_manager" across all community nodes.
 */
function _totem_user_get_managers_all_communities($reset = FALSE) {

  // Cache these values since this function is potentially called on a
  // per-user basis (e.g. /members).
  $key = __FUNCTION__;
  $gid = &drupal_static($key);

  if (empty($gid) || $reset) {
    $gid = db_query('SELECT na.gid FROM {node_access} AS na WHERE na.realm = :realm', array(
      ':realm' => 'totem_user_node_manager',
    ))->fetchCol();
  }

  return $gid;
}
/**
 * Helper function to get all uid values per role name.
 */
function _totem_user_get_users_by_role($role_name) {

  $query = db_select('users_roles', 'ur');
  $query->fields('ur', array('uid'));
  $query->join('role', 'r', 'ur.rid = r.rid');
  $result = $query
    ->condition('r.name', $role_name)
    ->execute()
    ->fetchCol();

  return $result;
}
/**
 * Checks that a node type = community and return node_access result if TRUE.
 */
function _totem_user_menu_access_callback_op_community($node, $op = 'view', $account, $task) {

  global $user;

  $access = _totem_common_menu_access_callback_op_community($node, $op);

  if ($access) {
    switch ($task) {
      case 'permissions':
      case 'remove':
        // Don't allow current user to permissions/remove self.
        if ($user->uid == $account->uid) {
          return FALSE;
        }

        // Don't allow node manager to permissions/remove owner.
        // Don't allow node member to permissions/remove owner.
        if ($node->uid == $account->uid) {
          return FALSE;
        }

        // Don't allow node member to permissions/remove admin.
        if (user_access('administer users', $account)) {
          return FALSE;
        }

        // Don't allow permissions/remove if user doesn't have community.
        $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
        if (!in_array($node->nid, $user_community)) {
          return FALSE;
        }
        break;

      case 'block':
        // Don't allow current user to block self.
        if ($user->uid == $account->uid) {
          return FALSE;
        }

        // Don't allow node member to block owner.
        if ($node->uid == $account->uid) {
          return FALSE;
        }

        // Don't allow node member to block admin.
        if (user_access('administer users', $account)) {
          return FALSE;
        }

        // Don't allow block if user is already blocked.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $account, 'field_community_blocked');
        if (in_array($node->nid, $user_community_blocked)) {
          return FALSE;
        }

        // Don't allow block if user is pending.
        $user_community_pending = _totem_common_get_field_entityreference_values('user', $account, 'field_community_pending');
        if (in_array($node->nid, $user_community_pending)) {
          return FALSE;
        }
        break;

      case 'unblock':
        // Only allow unblock if user is blocked.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $account, 'field_community_blocked');
        return in_array($node->nid, $user_community_blocked);
        break;

      case 'leave':
        // Don't allow node owner to leave own community.
        if ($node->uid == $account->uid) {
          return FALSE;
        }

        // Don't allow leave if user doesn't have community.
        $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
        if (!in_array($node->nid, $user_community)) {
          return FALSE;
        }
        break;

      case 'request_unblock':
        // Only allow request_unblock if user has been blocked from community.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $account, 'field_community_blocked');
        return in_array($node->nid, $user_community_blocked);
        break;

      case 'join':
        // Don't allow join if user has been blocked from community.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $account, 'field_community_blocked');
        if (in_array($node->nid, $user_community_blocked)) {
          return FALSE;
        }

        // Don't allow join if user already has community.
        $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
        if (in_array($node->nid, $user_community)) {
          return FALSE;
        }
        break;

      case 'approve':
        // Only allow approve if user is pending.
        $user_community_pending = _totem_common_get_field_entityreference_values('user', $account, 'field_community_pending');
        return in_array($node->nid, $user_community_pending);
        break;

      case 'invite':
        // Don't allow invite if user doesn't have community.
        $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
        if (!in_array($node->nid, $user_community)) {
          return FALSE;
        }
        break;
    }
  }
  else {
    switch ($task) {
      case 'join':
        // Although @totem_user_node_access may have returned DENY, we still
        // want to give denied user the chance to join community.
        $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
        if (!in_array($node->nid, $user_community)) {
          return TRUE;
        }
        break;

      case 'request_unblock':
        // Only allow request_unblock if user has been blocked from community.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $account, 'field_community_blocked');
        return in_array($node->nid, $user_community_blocked);
        break;
    }
  }

  return $access;
}
/**
 * TODO.
 */
function _totem_user_title_callback($title = NULL) {
  global $user;

  $user_profile = user_load($user->uid, FALSE);
  $user_profile = user_view($user_profile);

  $name = strip_tags(drupal_render($user_profile['field_name_first']));

  if (empty($name)) {
    $name = '';
  }

  return user_is_logged_in() ? t('Welcome @name', array('@name' => $name)) : t('Sign in');
}
/**
 * TODO.
 */
function _totem_user_title_callback_permissions($account, $node) {

  $grants_managers = db_query('SELECT na.gid FROM {node_access} AS na WHERE na.nid = :nid AND na.realm = :realm AND na.gid = :gid', array(
    ':nid' => $node->nid,
    ':realm' => 'totem_user_node_manager',
    ':gid' => $account->uid,
  ))->fetchCol();

  return (empty($grants_managers) ? 'Grant' : 'Revoke');
}
/**
 * Helper function to check if user has a field_community match with node.
 */
function _totem_user_has_community(&$account, &$node) {

  $user_has_community = FALSE;

  // We need to check if the node being passed in IS a community.
  // In that case, we know that the only nid connected to the node is itself.
  // So we're going immitate the output of the other function.
  if ($node->type == 'community') {
    $node_community[] = $node->nid;
  } else {
    $node_community = _totem_common_get_field_entityreference_values('node', $node, 'field_community');
  }
  $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');

  // Check that user has one of these field_community values.
  foreach ($node_community as $nid) {
    if (!$user_has_community) {
      $user_has_community = in_array($nid, $user_community);
    }
  }

  return $user_has_community;
}
/**
 * Returns the active user entity being viewed.
 */
function _totem_user_get_current_profile() {

  global $user;

  $account = NULL;

  // Try to load profile being viewed.
  $uid = arg(1);
  if (is_numeric($uid)) {
    $account = user_load($uid);
  }

  // Nothing loaded, default to current user.
  if (empty($account)) {
    $account = user_load($user->uid);
  }

  return $account;
}

// Hook implementations.
/**
 * Implements hook_hook_info_alter().
 */
function totem_user_hook_info_alter(&$hooks) {
  $hooks['form_alter']['group'] = 'form';
}
/**
 * Implements hook_permission().
 */
function totem_user_permission() {

  $perms = array(
    'administer totem' => array(
      'title' => t('Administer @site_name configuration.', array('@site_name' => variable_get('site_name'))),
    ),
  );

  return $perms;
}
/**
 * Implements hook_menu().
 */
function totem_user_menu() {

  // User registration modal callback.
  $items['user/modal/register'] = array(
    'title' => 'Register',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_account',
    'page arguments' => array('user_register_form', 'Register'),
    'access callback' => 'user_register_access',
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
    'options' => array(
      'attributes' => array(
        'class' => array('ctools-use-modal'),
      ),
    ),
  );

  // User login modal callback.
  $items['user/modal/login'] = array(
    'title' => 'Sign in',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_account',
    'page arguments' => array('user_login', 'Sign in'),
    'access callback' => 'user_is_anonymous',
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
    'options' => array(
      'attributes' => array(
        'class' => array('ctools-use-modal'),
      ),
    ),
  );

  // User password modal callback.
  $items['user/modal/password'] = array(
    'title' => 'Reset password',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_account',
    'page arguments' => array('user_pass', 'Reset password'),
    'access callback' => 'user_is_anonymous',
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
    'options' => array(
      'attributes' => array(
        'class' => array('ctools-use-modal'),
      ),
    ),
  );

  // Owner link to grant/revoke "manager" perms to member.
  $description = t("Add or remove this member's management privileges, allowing him or her to help moderate the content of this @community.", array(
    '@community' => t('Community'),
  ));
  $items['user/%user/permissions/%totem_common_context_community'] = array(
    'title' => 'Grant/Revoke',
    'title callback' => '_totem_user_title_callback_permissions',
    'title arguments' => array(1, 3),
    'description' => $description,
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(2, 3, 1),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can delete this community, they can
    // grant/revoke update privilege. Additional checks on action per %user.
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(3, 'delete', 1, 'permissions'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  // Manager link to block member from community.
  $description = t('Remove this member from the @community and block his or her future participation.', array(
    '@community' => t('Community'),
  ));
  $items['user/%user/modal/block/%totem_common_context_community'] = array(
    'title' => 'Block',
    'description' => $description,
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(3, 4, 1),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can update this community, they can block/unblock other members.
    // Additional checks on action per %user
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'update', 1, 'block'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  // Manager link to unblock and re-join member to community
  // (1-click, no modal).
  $description = t('Unblock this member and add them to the @community.', array(
    '@community' => t('Community'),
  ));
  $items['user/%user/unblock/%totem_common_context_community'] = array(
    'title' => 'Unblock',
    'description' => $description,
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(2, 3, 1),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can update this community, they can
    // block/unblock other members. Additional checks on action per %user.
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(3, 'update', 1, 'unblock'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  // Manager link to remove member from community.
  $description = t('Remove this member from the @community.', array(
    '@community' => t('Community'),
  ));
  $items['user/%user/modal/remove/%totem_common_context_community'] = array(
    'title' => 'Remove',
    'description' => $description,
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(3, 4, 1),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can update this community, they can remove
    // other members. Additional checks on action per %user.
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'update', 1, 'remove'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  // Manager link to approve member request to join community (only used for
  // Restricted and Closed communities).
  $description = t("Approve this member's request to join the @community.", array(
    '@community' => t('Community'),
  ));
  $items['user/%user/approve/%totem_common_context_community'] = array(
    'title' => 'Approve',
    'description' => $description,
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(2, 3, 1),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can update this community, they can approve join requests.
    // Additional checks on action per %user
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(3, 'update', 1, 'approve'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  // Member link to leave community
  $items['user/%user/modal/leave/%node'] = array(
    'title' => 'Leave Community',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    // For added safety, omit $account arg and default to global $user in
    // page callback.
    'page arguments' => array(3, 4),
    // Wrapper for $node->type == 'community' + node_access check if TRUE
    // Effective perm: if a user can update this community, they can block
    // other members. Additional checks on action per %user.
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'view', 1, 'leave'),
    'type' => MENU_CALLBACK,
  );

  // Callback to:
  //  - submit a request to append user's field_community LOV.
  $items['user/%user/modal/join/%node'] = array(
    'title' => 'Join Community',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(3, 4),
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'view', 1, 'join'),
    'type' => MENU_CALLBACK,
  );

  // Callback for 1-click Join on Open communities...we don't want a modal
  // here.
  // @see totem_user_menu_local_tasks_alter(), totem_user_block_view_button_add_user()
  $items['user/%user/open/join/%node']                   = $items['user/%user/modal/join/%node'];
  $items['user/%user/open/join/%node']['page arguments'] = array('join', 4);

  // Callback to:
  //  - submit a request to unblock user's field_community LOV.
  $items['user/%user/modal/request-unblock/%node'] = array(
    'title' => 'Request Unblock',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array('request_unblock', 4),
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'view', 1, 'request_unblock'),
    'type' => MENU_CALLBACK,
  );

  // Callback to:
  //  - invite users to append their field_community LOV.
  $items['user/%user/modal/invite/%node'] = array(
    'title' => 'Invite Friends',
    'file' => 'includes/totem_user.form.inc',
    'page callback' => 'totem_user_form_node',
    'page arguments' => array(3, 4),
    'access callback' => '_totem_user_menu_access_callback_op_community',
    'access arguments' => array(4, 'view', 1, 'invite'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}
/**
 * Implements hook_menu_alter().
 */
function totem_user_menu_alter(&$items) {

  $items['user/register']['title']  = 'Register';
  $items['user/register']['weight'] = 10;
  $items['user/login']['title']     = 'Sign in';
  $items['user/login']['weight']    = 20;
  $items['user/password']['title']  = 'Reset password';
  $items['user/password']['weight'] = 30;

  $items['user/%user/view']['title']  = 'Overview';
  $items['user/%user/view']['weight'] = -90;

  $items['user']['title callback'] = '_totem_user_title_callback';
  $items['user']['weight']         = -50;

  $items['user/logout']['title']  = ' &ndash; Sign out';
  $items['user/logout']['weight'] = -49;

  $items['user/%user/edit']['title']  = 'Settings';
  $items['user/%user/edit']['weight'] = -48;
}
/**
 * Implements hook_menu_local_tasks_alter().
 */
function totem_user_menu_local_tasks_alter(&$data, $router_item, $root_path) {

  // Add action link to 'messages/new' on 'user/%/messages' page.
  if ($router_item['tab_root'] == 'node/%') {

    global $user;

    $node = NULL;
    foreach ($router_item['page_arguments'] as $ix => &$meta) {
      if (is_object($meta)) {
        $node = $meta;
      }
    }

    if (!empty($node)) {
      if ($node->type == 'community') {

        // Add "Join community" link
        $path = 'user/' . $user->uid . '/modal/join/' . $node->nid;
        $item = menu_get_item($path);

        // 2013-06-05, natemow. Per new use of "access community node view",
        // user may or may not be anonymous.
        if ($item['access'] && user_is_logged_in()) {

          $node_entity = entity_metadata_wrapper('node', $node);
          if ($node_entity->field_community_status->value() == TOTEM_COMMUNITY_STATUS_OPEN) {
            // "Open" community; don't return modal link. See
            // totem_user_form_node:$op=add for link action as well.
            // @see totem_user_form_node()
            $path = str_ireplace('modal/', 'open/', $path);
          }

          $data['actions']['output'][] = array(
            '#theme' => 'menu_local_action',
            '#link' => array(
              'title' => t('Join @community', array('@community' => t('Community'))),
              'href' => $path,
              'localized_options' => array(
                'attributes' => array(
                  'class' => array('btn', 'small', 'corners', 'join-invite'),
                ),
              ),
            ),
          );
        }

        // Add "Request unblock" link
        $path = 'user/' . $user->uid . '/modal/request-unblock/' . $node->nid;
        $item = menu_get_item($path);

        if ($item['access']) {
          $data['actions']['output'][] = array(
            '#theme' => 'menu_local_action',
            '#link' => array(
              'title' => t('Join @community', array('@community' => t('Community'))),
              'href' => $path,
              'localized_options' => array(
                'attributes' => array(
                  'class' => array('btn', 'small', 'corners', 'join-invite'),
                ),
              ),
            ),
          );
        }

        // Add "Invite friends" link
        $path = 'user/' . $user->uid . '/modal/invite/' . $node->nid;
        $item = menu_get_item($path);

        if ($item['access']) {
          $data['actions']['output'][] = array(
            '#theme' => 'menu_local_action',
            '#link' => array(
              'title' => t('Invite Friends'),
              'href' => $path,
              'localized_options' => array(
                'attributes' => array(
                  'class' => array('btn', 'small', 'corners', 'join-invite'),
                ),
              ),
            ),
          );
        }

        // Add "Leave community" link
        $path = 'user/' . $user->uid . '/modal/leave/' . $node->nid;
        $item = menu_get_item($path);

        if ($item['access']) {
          $data['actions']['output'][] = array(
            '#theme' => 'menu_local_action',
            '#link' => array(
              'title' => t('Leave @community', array('@community' => t('Community'))),
              'href' => $path,
              'localized_options' => array(
                'attributes' => array(
                  'class' => array('btn', 'small', 'corners', 'leave-user'),
                ),
              ),
            ),
          );
        }
      }
    }
  }
}
/**
 * Implements hook_url_outbound_alter().
 *
 * PERMISSION
 */
function totem_user_url_outbound_alter(&$path, &$options, $original_path) {

  global $user;

  // Alter closed Community node paths to go straight to the join modal. See
  // totem_common_preprocess_node() for modal CSS class attribute.
  // @see totem_common_preprocess_node()
  if (!empty($options['entity_type'])) {
    $entity = &$options['entity'];

    if ($options['entity_type'] == 'node') {
      // We need to make sure that "entity" is a community.
      // TODO: we need some sort of fallback here, if a community isn't linked.
      if ($entity->type != 'community') {
        if (!empty($entity->field_community)) {
          $cid = $entity->field_community['und'][0]['target_id'];
          $community = node_load($cid);
        } else {
          // TODO: do something when field_community is empty.
          $cid = $entity->nid;
          $community = $entity;
        }
      } else {
        $cid = $entity->nid;
        $community = $entity;
      }
      
      if (!node_access('view', $community)) {
        $path = (user_is_logged_in() ? "user/{$user->uid}/modal/join/{$cid}" : 'user/modal/login');

        // Return request_unblock form if user is currently blocked.
        $user_community_blocked = _totem_common_get_field_entityreference_values('user', $user, 'field_community_blocked');
        if (in_array($cid, $user_community_blocked)) {
          $path = "user/{$user->uid}/modal/request-unblock/{$cid}";
        }
        $options['query']['destination'] = $original_path;
        $options['alias'] = $path;
      }

    }
    elseif ($options['entity_type'] == 'user') {
      // TODO: Fix this... /members doesn't seem to be hitting this.
      if (!user_access('access user profiles')) {
        $path = 'user/modal/login';
        $options['query']['destination'] = $original_path;
        $options['alias'] = $path;
      }

    }
  }

  // Alter core user paths to instead point to modal implementations of same.
  switch ($path) {
    case 'user/password':
      $path = 'user/modal/password';
      break;

    case 'user/register':
      $path = 'user/modal/register';
      break;

    case 'user/login':
      $path = 'user/modal/login';
      break;
  }

  if (in_array($path, array('user/modal/login', 'user/modal/register')) && empty($options['query']['destination'])) {
    $destination = request_path();
    if (empty($destination)) {
      $destination = 'user';
    }

    $options['query']['destination'] = $destination;
  }
}
/**
 * Implements hook_theme().
 */
function totem_user_theme($existing, $type, $theme, $path) {
  return array(
    'totem_user_block_user_profile' => array(
      'template' => 'theme/totem-user-block-user-profile',
      'variables' => array('user_profile' => NULL, 'is_own_profile' => NULL, 'user_has_communities' => NULL, 'block' => NULL),
    ),
    'totem_user_fboauth_invite' => array(
      'file' => 'includes/totem_user.form.inc',
      'variables' => array(),
    ),
  );
}
/**
 * Implements hook_theme_registry_alter().
 */
function totem_user_theme_registry_alter(&$theme_registry) {
  $path = drupal_get_path('module', 'totem_user');
  _totem_common_theme_registry_alter($theme_registry, $path);
}
/**
 * Implements hook_search_info().
 */
function totem_user_search_info() {
  return array(
    'title' => 'Members',
    'path' => 'totem_user',
  );
}
/**
 * Implements hook_search_execute().
 */
function totem_user_search_execute($keys = NULL, $conditions = NULL) {

  $query = db_select('search_index', 'i', array('target' => 'slave'))
    ->distinct(TRUE)
    ->fields('u', array('uid'))
    ->extend('SearchQuery');

  $query
    ->join('users', 'u', 'u.uid = i.sid');

  $query
    ->condition('u.status', 1)
    ->searchExpression($keys, 'totem_user');

  $query
    ->setOption('type', 'i.type');

  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  return array(
    'entity_type' => 'user',
    'entity_id' => $query->execute()->fetchCol(),
  );

}
/**
 * Implements hook_update_index().
 */
function totem_user_update_index() {

  $limit = (int) variable_get('search_cron_limit');

  $result = db_query_range("
    SELECT u.uid
    FROM {users} u
    LEFT JOIN {search_dataset} d on d.type = 'totem_user'
    AND d.sid = u.uid
    WHERE (d.sid IS NULL AND u.uid > 0)
    OR d.reindex <> 0
    ORDER BY d.reindex ASC, u.uid ASC", 0, $limit);

  foreach ($result as $user) {
    $user = user_load($user->uid);

    // Render the user. Note that this will force any fields exposed in the
    // search_index view mode to be indexed.
    user_build_content($user, 'search_index');
    $user->rendered = drupal_render($user->content);
    $text = '<h1>' . check_plain($user->realname) . '</h1>' . $user->rendered;

    // Update index.
    search_index($user->uid, 'totem_user', $text);
  }

}
/**
 * Implements hook_node_grants().
 *
 * PERMISSION
 */
function totem_user_node_grants($account, $op) {

  $grants['totem_user_node_manager'] = array($account->uid);
  $grants['totem_user_node_author'] = array($account->uid);

  return $grants;
}
/**
 * Implements hook_node_access_records().
 *
 * PERMISSION
 */
function totem_user_node_access_records($node) {

  $grants = array();

  if ($node->type == 'community') {
    $realm = 'totem_user_node_manager';

    // Make sure community author always has "manager" perms; these are
    // inherited in totem_user_node_access custom checking, and essentially
    // allows author to update/delete any other subnode in their community.
    $grants[] = array(
      'realm' => $realm,
      'gid' => $node->uid,
      'grant_view' => 1,
      'grant_update' => 1,
      'grant_delete' => 0,
      'priority' => 0,
    );

    // Make sure that "managers" continue to be managers of this node after
    // caches are cleared. Changes to grants should also be made in
    // totem_user_form_node:$op=permissions
    // @see totem_user_form_node()
    $grants_managers = db_query('SELECT na.gid FROM {node_access} AS na WHERE na.nid = :nid AND na.realm = :realm AND na.gid <> :gid', array(
      ':nid' => $node->nid,
      ':realm' => $realm,
      ':gid' => $node->uid,
    ))->fetchCol();

    foreach ($grants_managers as $uid) {
      $grants[] = array(
        'realm' => $realm,
        'gid' => $uid,
        'grant_view' => 1,
        'grant_update' => 1,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }

  }
  else {

    // Make sure node author always has full perms to unpublished nodes.
    // This is key for the "All/Private" feature.
    // @see totem_common_query_NODE_FILTER_alter()
    if (empty($node->status)) {
      $realm = 'totem_user_node_author';

      $grants[] = array(
        'realm' => $realm,
        'gid' => $node->uid,
        'grant_view' => 1,
        'grant_update' => 1,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }

  }

  return $grants;
}
/**
 * Implements hook_node_access().
 *
 * PERMISSION
 */
function totem_user_node_access($node, $op, $account = NULL) {

  $type = is_string($node) ? $node : $node->type;
  $access = NODE_ACCESS_IGNORE;

  // Note that totem_[mod].install files are setting the required
  // node_permissions_[type] variables for this check; each content
  // type defined by the feature mods will also have the required
  // field_community instance applied.
  $types = node_permissions_get_configured_types();
  if (!in_array($type, $types)) {
    return $access;
  }

  // Always allow access to custom 403 and 404 nodes.
  if ($type == 'page' && $op == 'view') {
    if (!empty($node->nid)) {
      if ("node/{$node->nid}" == variable_get('site_403')) {
        $access = NODE_ACCESS_ALLOW;
      }
      if ("node/{$node->nid}" == variable_get('site_404')) {
        $access = NODE_ACCESS_ALLOW;
      }
    }

    if ($access == NODE_ACCESS_ALLOW) {
      return $access;
    }
  }

  // Get user's field_community LOV.
  $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
  $user_has_community = FALSE;

  switch ($op) {
    case 'create':
      /*
        * User is accessing:
        * - node/add/type
        * - node/add/type/[nid]
        * - community/add/[type]/[nid]
        *
        * - community/add/[type]/[community nid] (modal context)
        * - node/add/[type]
        * - node/add/[type]/[community nid]
        *
        * Note that the custom "Add [type]" button blocks are wrapped in a
        * call to node_access to control visibility.
        */
      $node_community_context = _totem_common_get_community_context_node();

      /*
        * Check that user belongs to contextual community node.
        */
      if ($node_community_context) {
        $user_has_community = in_array($node_community_context->nid, $user_community);
      }

      /*
        * User is just creating a new basic Community node, not adding a node
        * to an existing one.
        *
        * Rely on user_access check for Resources node types.
        */
      $resources = array_keys(_totem_common_node_types(TRUE));
      if ($type == 'community') {
        // Check for "create community content" perm.
        $user_has_community = user_access("create {$type} content", $account);
      }
      elseif (in_array($type, $resources)) {
        // Check for "create [resource] content" perm.
        $user_has_community = user_access("create {$type} content", $account);
      }
      elseif (in_array('moderator', $account->roles)) {
        // Check for "moderator" role.
        $user_has_community = TRUE;
      }

      if (!$user_has_community) {
        $access = NODE_ACCESS_DENY;
      }
      else {
        $access = NODE_ACCESS_ALLOW;
      }

      break;
    case 'update':
    case 'delete':
      /*
        * User is accessing:
        * - node/[community nid] (community landing page)
        * - node/[community nid]/MENU_LOCAL_TASK (community tab)
        * - any node teaser list
        *
        * This node_access check accounts for contextual edit/delete links on node lists.
        *
        * User is accessing:
        * - community/edit/[nid] (modal context)
        * - community/edit/[nid] (modal context)
        *
        * This node_access check accounts for the actual modal add/edit form.
        */

      // We could be viewing this node in any community's context, since a
      // single internal_node could reference multiple communities. If user
      // has update/delete grants in ANY of the ref'd communities, allow $op
      // here.
      // Get node's field_community LOV.
      $node_community_context = ($node->type == 'community' ? array($node->nid) : _totem_common_get_field_entityreference_values('node', $node, 'field_community'));

      // Check that user has one of these field_community values.
      foreach ($node_community_context as $nid) {
        if (!$user_has_community) {
          $user_has_community = in_array($nid, $user_community);
        }
      }

      $access = NODE_ACCESS_DENY;

      // Always allow update/delete by author regardless of whether they have
      // one of the ref'd communities.
      if ($node->uid == $account->uid) {
        $access = NODE_ACCESS_ALLOW;
      }
      else {
        if (empty($node->status)) {
          // Deny access if node is unpublished, regardless of manager perms
          // granted in current community.
          return $access;
        }
      }

      // Honor "any" perms applied by admins (e.g. "moderator" role).
      if ($op == 'update') {
        if (user_access("edit any {$type} content", $account)) {
          $access = NODE_ACCESS_ALLOW;
        }
      }
      if ($op == 'delete') {
        if (user_access("delete any {$type} content", $account)) {
          $access = NODE_ACCESS_ALLOW;
        }
      }

      // Check for "manager" node_access grants to user.
      // Note auto=assignment for community authors in:
      // @see totem_user_node_access_records()
      if ($user_has_community && $access == NODE_ACCESS_DENY) {

        // Last chance...see if user has been granted $op perms on this node
        // (i.e. the actual community node), OR has inherited $op perms from
        // 1 of node's referenced community grants (i.e. "manager" role)
        if (module_implements('node_grants')) {
          $query = db_select('node_access');
          $query->addExpression('1');
          $query->condition('grant_' . $op, 1, '>=');
          $nids  = db_or()->condition('nid', $node_community_context);
          if ($node->status) {
            $nids->condition('nid', 0);
          }
          $query->condition($nids);
          $query->range(0, 1);

          $grants = db_or();
          foreach (node_access_grants($op, $account) as $realm => $gids) {
            foreach ($gids as $gid) {
              $grants->condition(db_and()
                ->condition('gid', $gid)
                ->condition('realm', $realm)
              );
            }
          }
          if (count($grants) > 0) {
            $query->condition($grants);
          }
          $result = (bool) $query
              ->execute()
              ->fetchField();

          if ($result) {
            $access = NODE_ACCESS_ALLOW;
          }
        }
      }
      break;

    case 'view':
      /*
        Album Privacy - Albums can be set to Open, Restricted, or Closed to control album access - The default album access is “Open”
        a. Open and Restricted albums can be viewed by all members
        b. Open and Restricted albums can be included in search results for all users including anonymous
        c. Anonymous users can only see the album summary as defined in “Search”
        d. Open albums can be joined by all members (see totem_user_block_view_button_add_user)
        e. All members can request to join Restricted albums
        f. Restricted albums require approved membership from a Manager to join
        g. Closed albums require membership to be viewed
        h. Closed albums require approved membership from a Manager to join
        i. Closed albums can be included in search results
        j. Selecting a Closed album from search results will present the “Request Membership” form
        */

      // Regardless of community membership, deny access to unpublished
      // nodes if not author or "view own" perm not active.
      
      if (empty($node->status)) {
        if ($node->uid !== $account->uid) {
          $access = NODE_ACCESS_DENY;
        }
        else {
          if (!user_access('view own unpublished content', $account)) {
            $access = NODE_ACCESS_DENY;
          }
        }

        if ($access == NODE_ACCESS_DENY) {
          return $access;
        }
      }

      // Let moderators view everything.
      if (in_array('moderator', $account->roles)) {
        $access = NODE_ACCESS_ALLOW;
        return $access;
      }


      $node_community = NULL;
      if ($node->type == 'community') {
        // Community node
        $node_community = $node;
      }
      else {
        // Internal node associated to Community **OR** non-community
        // type (e.g. "page")
        $node_community = _totem_common_get_community_context_node();
      }

      if (!empty($node_community)) {
        // Check if user has community.
        $user_has_community = in_array($node_community->nid, $user_community);

        if ($user_has_community) {
          // User belongs to this community; grant access.
          $access = NODE_ACCESS_ALLOW;
        }
        else {
          if (!user_access('access community node view', $account)) {
            $access = NODE_ACCESS_DENY;
          }
          else {
            $node_community_entity = entity_metadata_wrapper('node', $node_community);
            switch ($node_community_entity->field_community_status->value()) {
              // Open.
              case TOTEM_COMMUNITY_STATUS_OPEN:
              // Restricted.
              case TOTEM_COMMUNITY_STATUS_RESTRICTED:
                $access = NODE_ACCESS_ALLOW;
                break;

              // Closed.
              case TOTEM_COMMUNITY_STATUS_CLOSED:
                // See totem_user_url_outbound_alter for the link
                // alter that points to login or Join Community modal.
                // @see totem_user_url_outbound_alter()
                $access = NODE_ACCESS_DENY;
                break;
            }
          }
        }

      }
      else {
        // No community context node available...do some additional checks.

        // Check access to "resource" node types per internal_nodes perm.
        $resources = _totem_common_node_types(TRUE);
        $resources = array_keys($resources);
        if (in_array($node->type, $resources)) {
          if (!user_access("access {$node->type} node view", $account)) {
            return NODE_ACCESS_DENY;
          }
        }

        // User may be attempting to view default node/% or node/%/view
        // paths. Don't love relying exclusively on internal_nodes, so do
        // some double-checking to grant/deny access if part of any community
        // and per community status.
        $node_community = _totem_common_get_field_entityreference_values('node', $node, 'field_community');
        if (!empty($node_community)) {
          $types = _totem_common_node_types();
          $types = array_keys($types);
          if (in_array($node->type, $types)) {
            if (!user_access('access community node view', $account)) {
              $access = NODE_ACCESS_DENY;
            }
            else {
              // TODO: Improve this fugliness.
              $node_community = node_load($node_community[0]);

              $node_community_entity = entity_metadata_wrapper('node', $node_community);
              switch ($node_community_entity->field_community_status->value()) {
                // Open.
                case TOTEM_COMMUNITY_STATUS_OPEN:
                // Restricted.
                case TOTEM_COMMUNITY_STATUS_RESTRICTED:
                  $access = NODE_ACCESS_ALLOW;
                  break;

                // Closed.
                case TOTEM_COMMUNITY_STATUS_CLOSED:
                  // See totem_user_url_outbound_alter for the link
                  // alter that points to login or Join Community modal.
                  // @see totem_user_url_outbound_alter()
                  $access = NODE_ACCESS_DENY;
                  break;
              }
            }
          }
        }

      }
      break;
  }


  return $access;
}
/**
 * Implements hook_user_presave().
 */
function totem_user_user_presave(&$edit, $account, $category) {

  $account_cancellation = FALSE;

  if ($category == 'account') {
    if (!empty($edit['data']) && !empty($edit['data']['user_cancel_method'])) {
      $account_cancellation = TRUE;
    }

    if (!$account_cancellation) {
      if (array_key_exists('mail', $edit)) {
        $edit['name'] = $edit['mail'];
      }
    }
  }
}
/**
 * Implements hook_user_view_alter().
 */
function totem_user_user_view_alter(&$build, $type) {

  $account = &$build['#account'];

  // Fix for anon content (e.g. from Devel Generate).
  if (empty($account->uid)) {
    return;
  }

  // Add user contextual links.
  $build['#contextual_links']['user'] = array('user', array($account->uid));

  // Append linked Realname output.
  $realname = format_username($account);
  $account->content['name'] = array(
    '#markup' => theme_username(array(
      'account' => $account,
      'name' => $realname,
      'link_path' => 'user/' . $account->uid,
      'link_options' => array(
        'attributes' => array(
          'class' => array('tooltip-info'),
        ),
      ),
      'attributes_array' => array(),
      'extra' => '',
    )),
  );

  // Add user picture styles.
  $uri = !empty($account->picture) ? $account->picture->uri : variable_get('user_picture_default');
  $images_args = array(
    'alt' => $realname,
  );

  // Reduce the number of images that GD has to generate.
  if (in_array($build['#view_mode'], array('teaser', 'full'))) {
    $images_args['styles'] = array('user_thumb');
  }
  $images = _totem_common_image_styles($uri, $images_args);
  foreach ($images as $style_name => $image) {
    $images[$style_name] = l($image, "user/{$account->uid}", array(
      'html' => TRUE,
      'attributes' => array(
        'class' => array('tooltip-info'),
      ),
    ));
  }

  $account->content['images'] = $images;


  // Add "Manager" or "Owner" label where appropriate.
  $label_perms = 'Manager';
  $node_community_context = _totem_common_get_community_context_node();
  $node_community_managers = array();
  $account_is_moderator = in_array($account->uid, _totem_user_get_users_by_role('moderator'));

  if (!empty($node_community_context)) {
    // Get managers of contextual community node.
    $node_community_managers = _totem_user_get_managers($node_community_context);

    // Set to "Leader" if author.
    if ($account->uid == $node_community_context->uid) {
      $label_perms = 'Leader';
    }
  }
  else {
    // Get managers of all community nodes.
    $node_community_managers = _totem_user_get_managers_all_communities();

    // Set to "Owner" if author of any field_community values.
    $user_community = _totem_common_get_field_entityreference_values('user', $account, 'field_community');
    if (!empty($user_community)) {
      $sql = "SELECT n.uid FROM {node} AS n WHERE n.nid IN (:nid) AND n.uid = :uid";
      $user_community = db_query($sql, array(
        ':nid' => $user_community,
        ':uid' => $account->uid,
      ))->fetchCol();
    }

    if (in_array($account->uid, $user_community)) {
      $label_perms = 'Leader';
    }
  }


  // Add "Moderator" label where appropriate.
  if ($account_is_moderator) {
    $label_perms = 'Moderator';
  }

  // Now actually add the label.
  $account->content['label_perms'] = NULL;
  if (in_array($account->uid, $node_community_managers) || $account_is_moderator) {
    $account->content['label_perms'] = array(
      '#type' => 'markup',
      '#markup' => l(t($label_perms) . " <span>&raquo;</span>", "user/{$account->uid}", array(
        'html' => TRUE,
        'attributes' => array(
          'class' => array('manager'),
        ),
      )),
    );
  }

  // Everything after is only for full profile views.
  if ($build['#view_mode'] !== 'full') {
    return;
  }


  $account->content['menu_local_task'] = &drupal_static(__FUNCTION__);
  if (empty($account->content['menu_local_task'])) {
    $path_part = arg(2);
    $menu_item = menu_get_item("user/{$account->uid}/{$path_part}");
    if (!empty($menu_item)) {
      if ($menu_item['href'] == drupal_get_path_alias()) {
        $type = $menu_item['page_arguments'][1];
        $types = _totem_common_types_info();
        if (is_string($type) && in_array($type, array_keys($types))) {
          $hook = "user_community_{$type}";
          foreach (module_implements($hook) as $module) {
            $query = NULL;
            $items = module_invoke($module, $hook, array(
              'account' => $account,
              'page_limit' => PAGE_SIZE_LISTS_PAGE,
            ));

            $query = _totem_common_efq_extract_query($items);

            // Force correct h1 page title for MENU_LOCAL_TASK callbacks.
            drupal_set_title($menu_item['title']);

            // Force new view_mode and set renderable content.
            $build['#view_mode'] = 'menu_local_task';
            if (!empty($query) && count($query->results) > 0) {
              $account->content['menu_local_task'] = array(
                '#theme' => 'totem_common_paged_entities',
                '#query' => $query,
                '#title' => $menu_item['title'],
              );
            }
            else {
              // Set empty resultset message.
              $account->content['menu_local_task'] = array(
                '#type' => 'markup',
                '#markup' => $types[$type]->no_results_text_user,
              );
            }

          }
        }
      }
    }
  }

}
/**
 * Implements hook_mail().
 */
function totem_user_mail($key, &$message, $params) {

  switch ($key) {
    case 'invite_nonmembers':
      $node           = $params['node'];
      $node_entity    = entity_metadata_wrapper('node', $node);
      $account        = $params['account'];
      $invite_message = $params['invite_message'];
      $subject        = t('"@title" - invitation to join', array('@title' => $node->title));
      $body    = t('<p>!name has invited you to join !title. To join, follow these steps:</p><ol>', array('!name' => l($account->realname, 'user/' . $account->uid, array('absolute' => TRUE)), '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE))));
      $body .= t('
        <li>Create an account at !site_url.</li>
        <li>Visit the !title @community.</li>
        <li>Request permission to join by clicking the "Join @community" button.</li>
      ', array(
        '!site_url' => l($_SERVER['HTTP_HOST'], '', array('absolute' => TRUE)),
        '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE)),
        '@community' => t('Community')
        ));

      $body .= '</ol>';
      $body .= t('<p>@name wrote:</p>', array('@name' => $account->realname));
      $body .= $invite_message;

      $message['subject'] = $subject;
      $message['body'][]  = $body;
      break;

    case 'invite_members':
      $node           = $params['node'];
      $node_entity    = entity_metadata_wrapper('node', $node);
      $account        = $params['account'];
      $invite_message = $params['invite_message'];
      $subject        = t('"@title" - invitation to join', array('@title' => $node->title));
      $body    = t('<p>!name has invited you to join !title. To join, follow these steps:</p><ol>', array('!name' => l($account->realname, 'user/' . $account->uid, array('absolute' => TRUE)), '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE))));

      // Set body per Community status.
      switch ($node_entity->field_community_status->value()) {
        case TOTEM_COMMUNITY_STATUS_OPEN:
          // Open
          $body .= t('
            <li>Visit the !title @community.</li>
            <li>Click the "Join @community" button.</li>
          ', array(
            '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE)),
            '@community' => t('Community')
            ));
          break;

        case TOTEM_COMMUNITY_STATUS_RESTRICTED:
          // Restricted
          $body .= t('
            <li>Visit the !title @community.</li>
            <li>Request permission to join by clicking the "Join @community" button.</li>
          ', array(
            '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE)),
            '@community' => t('Community')
            ));
          break;

        case TOTEM_COMMUNITY_STATUS_CLOSED:
          // Closed
          $body .= t('
            <li>Visit the !title @community.</li>
            <li>Request permission to join by clicking the "Join @community" button.</li>
          ', array(
            '!site_url' => l($_SERVER['HTTP_HOST'], '', array('absolute' => TRUE)),
            '!title' => l($node->title, 'node/' . $node->nid . '/members', array('absolute' => TRUE)),
            '@community' => t('Community')
            ));
          break;
      }

      $body .= '</ol>';
      $body .= t('<p>@name wrote:</p>', array('@name' => $account->realname));
      $body .= $invite_message;


      $message['subject'] = $subject;
      $message['body'][]  = $body;
      break;

  }
}
/**
 * Implements hook_query_TAG_alter().
 */
function totem_user_query_MANAGERS_COME_FIRST_alter(QueryAlterableInterface $query) {

  // Get community node var.
  $node_community_context = $query->getMetaData('node_community_context');

  if (!empty($node_community_context)) {
    // Get cached community managers list.
    $node_community_managers = _totem_user_get_managers($node_community_context);

    // Add derived "is_manager" field.
    $query->addExpression("
      CASE
        WHEN entity_id = :uid_author THEN 2
        WHEN entity_id IN (:managers) THEN 1
        ELSE 0
      END", 'is_manager',
      array(
        ':uid_author' => $node_community_context->uid,
        ':managers' => $node_community_managers,
      ));

    // Get reference to existing ORDER BY expressions.
    $order_by =& $query->getOrderBy();
    // Store existing expressions.
    $order_by_tmp = $order_by;
    // Clear existing expressions.
    $order_by = array();

    // Add "is_manager" field as first expression.
    $query->orderBy('is_manager', 'DESC');

    // Re-add existing expressions.
    foreach ($order_by_tmp as $field => $direction) {
      $query->orderBy($field, $direction);
    }

    //dpm( $query->__toString() );
  }
}

// Hook implementations (Features).
/**
 * Implements hook_node_community_ENTITY_TYPE().
 */
function totem_user_node_community_user($vars) {

  $efq_params = array(
    'entity_type' => 'user',
    'property_conditions' => array(),
    'field_conditions' => array(
      array('field' => 'field_community', 'column' => 'target_id', 'value' => $vars['node']->nid),
    ),
    'page_limit' => (!empty($vars['page_limit']) ? $vars['page_limit'] : PAGE_SIZE_LISTS_PAGE),
    'property_order_by' => array(
      array('column' => 'created', 'direction' => 'DESC')
    ),
    // Do a query alter to force ORDER BY expression of:
    // 1) Owner
    // 2) Manager(s)
    // 3) users.created DESC
    'tags' => array('MANAGERS_COME_FIRST'),
    'meta_data' => array(
      array('key' => 'node_community_context', 'object' => $vars['node']),
    ),
  );

  // Allow modules to alter params.
  $efq_param_type = 'search';
  drupal_alter('totem_common_EFQ_params', $efq_params, $efq_param_type);

  $items['users'] = array(
    'query' => _totem_common_efq($efq_params),
  );

  return $items;
}
/**
 * Implements hook_totem_common_EFQ_params_alter().
 */
function totem_user_totem_common_EFQ_params_alter(&$vars, $type) {

  switch ($type) {
    case 'search':
      // Get querystring args.
      $args = drupal_get_query_parameters();
      if (empty($args)) {
        return FALSE;
      }

      if (!empty($args['status'])) {
        switch ($args['status']) {
          case 'manager':
            // Get specific manager uids associated to this community.
            // Have to get node again here because $vars['node'] isn't passed to
            // hook again onsubmit.
            $node = _totem_common_get_community_context_node();
            $gid = _totem_user_get_managers($node);
            $vars['property_conditions'][] = array('column' => 'uid', 'value' => $gid);

            break;
          case 'pending':
            // Get members pending approval.
            $vars['field_conditions'][0]['field'] = 'field_community_pending';

            break;
          case 'blocked':
            // Get members who have been blocked.
            $vars['field_conditions'][0]['field'] = 'field_community_blocked';

            break;
          case 'member':
          default:
            break;
        }
      }
      break;

    // Alter params in common menu callback totem_common_page_content_list().
    case 'content_list':
      if ($vars['bundle'] == 'user') {
        $vars['entity_type'] = 'user';
        // Users table doesn't have a 'changed' column.
        $vars['property_order_by'][0]['column'] = 'created';

        // Do a query alter to force ORDER BY expression of:
        // 1) Owner
        // 2) Manager(s)
        // 3) users.created DESC
        $vars['tags'][] = 'MANAGERS_COME_FIRST';
        // $vars['meta_data'][] = array('key' => 'node_community_context', 'object' =>$vars['node']);
      }

      break;
  }

}
