<?php
/**
 * @file
 * totem_rating.module
 */

require_once 'includes/totem_rating.form.inc';
require_once 'includes/totem_rating.block.inc';
// TODO: Use all/most of the old Apps Alliance rating algorithm, instead using
// the new vars defined at admin/totem.

/**
 * Common handler for stats queries and markup.
 *
 * The user rating calculation is handled here exclusively.
 *
 *
 *
 * ====================
 * Contribution weight documentation
 * ====================
 *
 * User is assigned a percentage per contribution type (comment, forum topic,
 * work, event). For example, if there are 18 comments site-wide, and User
 * has contributed 3 of those, User is assigned a 16.6667% contrib percentage.
 *
 *   (3/18 = x/100) = 16.6667%
 *
 * User contrib percentage is then applied to each contrib type's point
 * value. Continuing with the example above, User will receive .5 of the
 * possible 3 points assigned to the comment contrib type.
 *
 *   (16.6667/100 = x/3) = .500001 points = .5 points
 *
 * User's points are then summed and a new percentage for rating is
 * created. If User earned:
 *
 *   .5 of a possible 3 points for the Comment contrib type.
 *
 *      Rationale for 3 point weight: Comments are a useful contribution
 *      type for other developers. E.g. expert contributions/help to an
 *      existing thread, junior users canvasing community for further input,
 *      etc.
 *
 *   .66667 of a possible 1 points for the Forum topic contrib type.
 *
 *      Rationale for 1 point weight: Assumption is that most new forum
 *      topics will be open-ended questions to the community...they're not
 *      necessarily useful until comments are posted.
 *
 *   .5 of a possible 3 points for the Work contrib type.
 *
 *      Rationale for 3 point weight: Work samples are a useful contribution
 *      type for other developers. Particularly if there are code samples,
 *      repos, etc. added later on down the line. Generally speaking too, work
 *      can inform and expose app industry trends, how-to for particular app
 *      dev tasks, etc.
 *
 *    0 of a possible 1 points for the Event contrib type.
 *
 *      Rationale for 1 point weight: Any fool can post an event, and in most
 *      cases the contribution itself will only be relevant to a local community.
 *
 * ...User's systemic sum would be 1.66667. Expressed as a percentage of the
 * 8 possible points, User's rating is 20.833375%.
 *
 *   ((.5 + .66667 + .5 + 0)/8 = x/100) = 20.833375%
 *
 *
 * Each contrib type's weight is configurable from the module settings page.
 *
 * At this point in the calculation, User's rating is based purely on number of
 * contributions as related to the systemic totals and preset weights; it does
 * not yet account for the perceived usefulness of individual contributions. To
 * address this, User's contributions will also be weighted with the community's
 * valuation (i.e. the Fivestar rating applied to each item).
 *
 *
 *
 * ====================
 * Voting weight documentation
 * ====================
 *
 * An important step in this process is to keep the base point pool proportionally
 * greater than the bonus point pool that is created. To do so, each contrib
 * type's available point pool (see weight discussion above) is multiplied by
 * the number of votes applied to that contrib type.
 *
 *
 * Votes are handled the same across all contrib types. The value of a vote is
 * based on the count of system votes and community's average valuation of User's
 * contrib types. Here's how bonus points are calculated and applied to User's
 * rating:
 *
 *    1) The user's percentage acquisition of the available vote pool is applied.
 *    e.g. If Users comments have received 50% of the 100 total votes in the system,
 *    his individual bonus point possibility is 50. Other users are not penalized,
 *    rather their pool is also proportional to the voting responses their
 *    comments have generated.
 *
 *    2) User will have an average vote percentage available per contrib type,
 *    based on Fivestar's scale (i.e. increments of 20%). This percentage is
 *    multiplied by User's possible bonus point pool from step 1. So if User had
 *    an average 40% rating on his comments, he would receive 20 bonus points.
 *
 *        (.40 * 50) = 20 points.
 *
 *    3) User's bonus points are then summed with the contrib points earned to date.
 *
 * The final user rating formula then is:
 *
 *    ((SUM(contrib points) + SUM(votes points) * 100) / SUM(variable pool of system points))
 *
 *
 *
 * ====================
 * Profile weight documentation
 * ====================
 *
 * User can also optionally receive bonus points based on the profile completion.
 * Currently there are 21 fields presented on the profile form; if User set values
 * for 10 of those 21 fields, the profile completion percentage is 47.62%:
 *
 *    (10/21 = x/100) = 47.6190%
 *
 * The value of the profile point pool is calculated as a percentage of the total
 * system contrib points. If a site admin valued profile completion as a 50%
 * bonus award, and there were 150 contrib points availabe in the system, the
 * base pool of profile points would be:
 *
 *    (150 * .50) = 75 points
 *
 * This bonus point pool is then added to the system contrib pool in order to
 * factor in the profile's weight on total user rating. Based on User's 47.62%
 * profile completion, he would earn 35.715 bonus points:
 *
 *    (.4762 * 75) = 35.715 points
 *
 * User can also earn additional voting points based on the same Fivestar rating
 * system used for contrib points. Votes on a user profile are handled in the
 * same manner as votes for a particular contrib type.
 *
 *
 *
 * ====================
 * Future suggestions/ideas
 * ====================
 *
 * Determine other possible community valuation business rules per suggestions
 * below:
 *
 *    A) Valuation as determined by Moderators (i.e. industry insiders/experts
 *    who serve as moderators could be presented with a sliding valuation scale,
 *    effectively allowing them to guide trends, content tone, etc.
 *
 *    B) Future: Number of transactional responses generated (e.g. # of event
 *    registrations, # of comments generated, # of work downloads, etc.)
 */
function _totem_rating_user_score(&$account, $arg_settings = array('rating_info' => array(), 'type_info' => array(), 'return_info' => array())) {
  
  // We need a way to alter what's returned from this function.
  // Enter the settings array:
  /*
   * rating_info => This is directly related to the final "rating"
   *  -- progressive => If true, the returned score will not be displayed as
   *  --                "out of anything", Example (20.8 points) vs. (20.8 of 32 points)
   *  -- percentage => If true, the returned score will be shown as a Percent
   *  --               (regardless of the progressive setting)
   *  -- details => If true, the details will be returned, (20.8 of 32 points)
   *  --            if progressive is TRUE, the "of 32" would be removed.
   * 
   * type_info => This is pertaining to the returned type data.
   * -- score => If TRUE, the @type->name and values will be returned or rendered.
   * 
   * return_info => This determines what is returned.
   * -- type => If "markup" the function will render it's own version of the data.
   *            If it's set to anything else; it will return an array of data.
   *            (This could be elaborated on; not sure how though).
   */
  $default_settings = array(
    'rating_info' => array(
      'progressive' => FALSE,
      'percentage' => TRUE,
      'details' => TRUE,
      'vote_bonus' => TRUE,
      'vote_bonus_absolute' => FALSE,
      'debug' => TRUE,
    ),
    'type_info' => array(
      'score' => TRUE,
    ),
    'return_info' => array(
      'type' => 'markup',
    ),
  );
  
  // We're going to allow modules to alter the settings array first.
  drupal_alter('totem_rating_user_score_settings', $default_settings);
  
  // Now merge the settings passed through the function with the default.
  foreach ($default_settings as $key => $arr) {
    if (array_key_exists($key, $arg_settings)) {
      $function_settings[$key] = array_merge($default_settings[$key], $arg_settings[$key]);
    }
  }
    
  $debug = $function_settings['rating_info']['debug'];
  $settings = variable_get('totem_rating_settings');
  $types = _totem_common_types_info();
  $types['comment'] = (object) array(
    'name' => 'Comment',
  );
  
  // Vars used to hold counts, voting results and award points
  // Note: "profile" should always be placed at the end of these arrays, in
  // order to correctly weight it's value against the actual node contributions
  // in the system.
  $stats_base = array();
  foreach ($settings as $bundle => $meta) {
    $stats_base[$bundle] = 0;
  }

  $stats_contrib_user
    = $stats_contrib_system
    = $stats_points_contrib
    = $stats_points_votes
    = $stats_votes_user
    = $stats_votes_system
    = $stats_base;
  
  foreach ($settings as $bundle => $meta) {
    // Total available points assigned to each contribution type (adjust
    // ratio per client's business rule feedback).
    // @see http://example.com/admin/totem

    $stats_points_system[$bundle] = $meta['points'];
    $stats_votes_user[$bundle]
      = $stats_votes_system[$bundle] = NULL;

    // Get counts + votes.
    // Set entity_type per bundle.
    $entity_type = 'node';

    switch ($bundle) {
      case 'user':
        $entity_type = 'user';
        break;

      case 'comment':
        $entity_type = 'comment';
        break;
    }

    // User u/c/nid results.
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', $entity_type)
      ->propertyCondition('uid', $account->uid)
      ->propertyCondition('status', 1);

    // Set node type.
    if ($entity_type == 'node') {
      $query
        ->entityCondition('bundle', $bundle);
    }

    $result = $query->execute();

    // User u/c/nid votes.
    if (array_key_exists($entity_type, $result)) {
      $result = array_keys($result[$entity_type]);
      $stats_votes_user[$bundle] = votingapi_select_votes(array(
        'entity_type' => $entity_type,
        'entity_id' => $result,
      ));
    }

    // User u/c/nid count.
    $stats_contrib_user[$bundle] = count($result);

    // Total u/c/nid results.
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', $entity_type)
      ->propertyCondition('status', 1);

    // Set node type.
    if ($entity_type == 'node') {
      $query
        ->entityCondition('bundle', $bundle);
    }

    $result = $query->execute();

    // Total u/c/nid votes.
    if (array_key_exists($entity_type, $result)) {
      $result = array_keys($result[$entity_type]);
      $stats_votes_system[$bundle] = votingapi_select_votes(array(
        'entity_type' => $entity_type,
        'entity_id' => $result,
      ));
    }

    // Total u/c/nid count.
    $stats_contrib_system[$bundle] = count($result);

    // TODO: Insert profile completion stuff here?
    // Multiply base weight pool by the vote count. This keeps base pool more
    // valuable than votes.
    $stats_points_system[$bundle] = ($stats_points_system[$bundle] * $stats_contrib_system[$bundle]);
  }

  // Update arrays with user stats and add UI items
  $content = array();

  foreach ($stats_contrib_user as $bundle => $val) {
    // Set user's percentage of system contributions.
    $percentage_contrib = 0;
    if (!empty($stats_contrib_system[$bundle])) {
      $percentage_contrib = (($val * 100) / $stats_contrib_system[$bundle]);
    }

    // Calculate user's earned points (base).
    $stats_points_contrib[$bundle] = ($percentage_contrib * $stats_points_system[$bundle] / 100);

    // Set user's percentage of total votes.
    $percentage_votes = 0;
    $count_votes_system = count($stats_votes_system[$bundle]);
    $count_votes_user = count($stats_votes_user[$bundle]);

    if (!empty($stats_votes_system[$bundle])) {
      $percentage_votes = ((($count_votes_user * 100) / $count_votes_system) / 100);
    }

    // Calculate user's bonus vote points.
    if (!empty($stats_votes_user[$bundle])) {
      // Set average percent valuation per unique entity_id.
      $percentage_votes_contrib = array();
      foreach ($stats_votes_user[$bundle] as $ix => $meta) {
        if (!array_key_exists($meta['entity_id'], $percentage_votes_contrib)) {
          $percentage_votes_contrib[$meta['entity_id']] = array();
        }
        $percentage_votes_contrib[$meta['entity_id']][] = $meta['value'];
      }

      foreach ($percentage_votes_contrib as $entity_id => $ratings) {
        $percentage_votes_contrib[$entity_id] = (array_sum($ratings) / count($ratings));
      }

      // Set user's average valuation for his contribs of this type.
      $percentage_votes_contrib = ((array_sum($percentage_votes_contrib) / count($percentage_votes_contrib)) / 100);

      // Votes for user's contributions make up X% of system votes, so
      // allocate X% of the available bonus pool (vote count) to user.
      $stats_points_votes[$bundle] = ($percentage_votes * $count_votes_system);

      // Now multiply user's bonus award by community's valuation (avg vote %).
      $stats_points_votes[$bundle] = $stats_points_votes[$bundle] * $percentage_votes_contrib;
    }

    // Add UI item.
    if (!empty($val)) {
      $content[] = t($types[$bundle]->name_plural) . ' created: <span>' . $val . (!$function_settings['rating_info']['progressive'] ? '/' . $stats_contrib_system[$bundle] : '') . '</span>';
      if ($debug) {
        $content[] = '<div class="debug">(' . round($stats_points_contrib[$bundle], 2) . ' contrib'. ($function_settings['rating_info']['vote_bonus'] ? ' + ' . round($stats_points_votes[$bundle], 2) . ' vote points' : '') . ')</div>';
      }
    }
  }

  // Set vars for user and system point sums.
  $stats_points_contrib = array_sum($stats_points_contrib);
  if($function_settings['rating_info']['vote_bonus']) {
    $stats_points_contrib = $stats_points_contrib + array_sum($stats_points_votes);
  } 
  $stats_points_system = array_sum($stats_points_system);
  
  // Set user rating.
  $stats_contrib_user['rating'] = 0;
  if ($function_settings['rating_info']['percentage']) {
    if (!empty($stats_points_system)) {
      $stats_contrib_user['rating'] = (($stats_points_contrib * 100) / $stats_points_system);
    }
    $stats_contrib_user['rating'] = round($stats_contrib_user['rating'], 2) . '%';
  } else {
    if (!empty($stats_points_contrib)) {
      $stats_contrib_user['rating'] = round($stats_points_contrib, 2);
    }
  }
  
  // Add UI item.
  $rating_text = '<div class="debug">(';
  $rating_text .= round($stats_points_contrib, 2);
  if (!$function_settings['rating_info']['progressive']) {
  $rating_text .= ' of ' . round($stats_points_system, 2);
  }
  $rating_text .= ' points' . ')</div>';
  if ($debug) {
    array_unshift($content, $rating_text);
  }
  if ($function_settings['rating_info']['vote_bonus_absolute'] && array_sum($stats_points_votes) != 0) {
    $vote_bonus_abs_text = '<div class="vote-bonus-abs">Votes Received</div>';
    array_unshift($content, $vote_bonus_abs_text);
  }
  array_unshift($content, t('Rating') . ': <span>' . $stats_contrib_user['rating'] . '</span>');

  // Set return markup.
  switch ($function_settings['return_info']['type'] == 'markup') {
    case 'markup':
      if (!empty($content)) {
        $content = theme_item_list(array(
          'title' => t('Stats:'),
          'type' => 'ul',
          'items' => $content,
          'attributes' => array(
            'class' => array('stats'),
          ),
        )) . '<div class="clearfix"></div>';
      }

      else {
        $content = NULL;
      }
      break;
     
    default:
      if (!$function_settings['rating_info']['percentage']) {
        unset($stats_contrib_user['rating']);
      }
      // Create the data array.
      $content = array(
        'rating' => $stats_points_contrib,
        'counts_bundle' => $stats_contrib_user,
        'votes_obj_user' => $stats_votes_user,
      );
      if (!$function_settings['rating_info']['progressive']) {
        $content['counts_bundle_system'] = $stats_contrib_system;
        $content['votes_obj_system'] = $stats_votes_system;
      }
      if ($function_settings['rating_info']['vote_bonus']) {
        $content['votes_bonus_points'] = $stats_points_votes;
      }  
      if ($function_settings['rating_info']['vote_bonus_absolute']) {
        if (array_sum($stats_points_votes) != 0) {
          $content['votes_bonus_absolute'] = TRUE;
        } else {
          $content['votes_bonus_absolute'] = FALSE;
        }
      }
      break;
  }
  
  return $content;

/*

  // Debug switch
  $debug = _appsalliance_ui_variable_get('appsalliance_ui_rating_debug');

  // Global vars used to hold counts, voting results and award points
  // Note: "profile" should always be placed at the end of these arrays, in
  // order to correctly weight it's value against the actual node contributions
  // in the system.

  $stats_contrib_user =
  $stats_contrib_system =
  $stats_points_contrib =
  $stats_points_votes = array(
    'comment' => 0,
    'forum' => 0,
    'work' => 0,
    'event' => 0,
    'profile' => 0,
  );

  // Voting results
  $stats_votes_user =
  $stats_votes_system = array(
    'comment' => NULL,
    'forum' => NULL,
    'work' => NULL,
    'event' => NULL,
    'profile' => NULL,
  );

  // Total available points assigned to each contribution
  // type (adjust ratio per client's business rule feedback)
  $stats_points_system = array(
    'comment' => _appsalliance_ui_variable_get('appsalliance_ui_rating_comment_weight'),
    'forum' => _appsalliance_ui_variable_get('appsalliance_ui_rating_forum_weight'),
    'work' => _appsalliance_ui_variable_get('appsalliance_ui_rating_work_weight'),
    'event' => _appsalliance_ui_variable_get('appsalliance_ui_rating_event_weight'),
    'profile' => 0,
  );

  // Get counts + votes
  foreach ($stats_contrib_user as $bundle => $val) {
    // Set entity type
    $entity_type = NULL;
    switch ($bundle) {
      case 'profile':
        $entity_type = 'user';
        break;

      case 'comment':
        $entity_type = 'comment';
        break;

      default:
        $entity_type = 'node';
        break;
    }

    // User u/c/nid results
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', $entity_type)
      ->propertyCondition('uid', $account->uid)
      ->propertyCondition('status', 1);

     // Set node type
     if ($entity_type == 'node') {
      $query
        ->entityCondition('bundle', $bundle);
    }
    $result = $query->execute();

    // User u/c/nid votes
    if (array_key_exists($entity_type, $result)) {
      $result = array_keys($result[$entity_type]);
      $stats_votes_user[$bundle] = votingapi_select_votes(array(
        'entity_type' => $entity_type,
        'entity_id' => $result,
      ));
    }
 
    // User u/c/nid count
    $stats_contrib_user[$bundle] = count($result);\
 
    // Total u/c/nid results
    $query = new EntityFieldQuery();
    $query
      ->entityCondition('entity_type', $entity_type)
      ->propertyCondition('status', 1);

    // Set node type
    if ($entity_type == 'node') {
      $query
        ->entityCondition('bundle', $bundle);
    }
    $result = $query->execute();

    // Total u/c/nid votes
    if (array_key_exists($entity_type, $result)) {
      $result = array_keys($result[$entity_type]);
      $stats_votes_system[$bundle] = votingapi_select_votes(array(
        'entity_type' => $entity_type,
        'entity_id' => $result,
      ));
    }
    // Total u/c/nid count
    $stats_contrib_system[$bundle] = count($result);

    if ($bundle == 'profile') {
     // For profile completion, we want to base contribution percentage on the
     // number of fields that the user has populated; update counts here.
 
     // Get user profile field instances
     $result = db_select('field_config_instance', 'fcf')
        ->fields('fcf', array('field_name'))
        ->condition('fcf.entity_type', 'user', '=')
        ->condition('fcf.bundle', 'user', '=')
        ->condition('fcf.deleted', 1, '<>')
        ->orderBy('fcf.field_name', 'ASC')
        ->execute();

      // Assign 1 point for each field completed
      $profile = location_empty_location(array());
      $profile['picture'] = !empty($account->picture);
      $profile['country'] = NULL;

      while ($row = $result->fetchAssoc()) {
        $profile[$row['field_name']] = !empty($account->{$row['field_name']});
        if ($row['field_name'] == 'field_location' && $profile[$row['field_name']]) {
          $location = location_load_location($account->{$row['field_name']}['und'][0]['lid']);
          foreach ($location as $field => $val) {
            $profile[$field] = !empty($val);
          }
        }
      }

      // Don't award bonus points for hidden or meta fields
      $exclude = array('lid', 'name', 'additional', 'province_name', 'country_name', 'source', 'is_primary', 'delete_location', 'locpick', 'latitude', 'longitude');

      foreach ($exclude as $field) {
        unset($profile[$field]);
      }

      // Update counts
      $stats_contrib_user[$bundle] = array_sum($profile);
      $stats_contrib_system[$bundle] = count($profile);

      // Weight the profile to a percentage of the total system contrib points.
      $stats_points_system[$bundle] = ((array_sum($stats_points_system) * _appsalliance_ui_variable_get('appsalliance_ui_rating_profile_weight')) / 100);
    }
    else {
      // Multiply base weight pool by the vote count.
      // This keeps base pool more valuable than votes.
      $stats_points_system[$bundle] = ($stats_points_system[$bundle] * $stats_contrib_system[$bundle]);
    }

  }


  // Update arrays with user stats and add UI items
  $content = array();
  foreach ($stats_contrib_user as $bundle => $val) {

    // Set user's percentage of system contributions
    $percentage_contrib = (($val * 100) / $stats_contrib_system[$bundle]);

    // Calculate user's earned points (base)
    $stats_points_contrib[$bundle] = ($percentage_contrib * $stats_points_system[$bundle] / 100);

    // Set user's percentage of total votes
    $percentage_votes = 0;
    $count_votes_system = count($stats_votes_system[$bundle]);
    $count_votes_user = count($stats_votes_user[$bundle]);
    if (!empty($stats_votes_system[$bundle])) {
      $percentage_votes = ((($count_votes_user * 100) / $count_votes_system) / 100);
    }

    // Calculate user's bonus vote points
    if (!empty($stats_votes_user[$bundle])) {

      // Set average percent valuation per unique entity_id
      $percentage_votes_contrib = array();
      foreach ($stats_votes_user[$bundle] as $ix => $meta) {
        if (!array_key_exists($meta['entity_id'], $percentage_votes_contrib)) {
          $percentage_votes_contrib[$meta['entity_id']] = array();
        }
        $percentage_votes_contrib[$meta['entity_id']][] = $meta['value'];
      }

      foreach ($percentage_votes_contrib as $entity_id => $ratings) {
        $percentage_votes_contrib[$entity_id] = (array_sum($ratings) / count($ratings));
      }

      // Set user's average valuation for his contribs of this type
      $percentage_votes_contrib = ((array_sum($percentage_votes_contrib) / count($percentage_votes_contrib)) / 100);

      // Votes for user's contributions make up X% of system votes, so
      // allocate X% of the available bonus pool (vote count) to user
      $stats_points_votes[$bundle] = ($percentage_votes * $count_votes_system);

      // Now multiply user's bonus award by community's valuation (avg vote %)
      $stats_points_votes[$bundle] = $stats_points_votes[$bundle] * $percentage_votes_contrib;
    }

    // Add UI item
    if (!empty($val)) {
      $label = 'Label';
      switch ($bundle) {
        case 'profile': $label = 'Profile'; break;
        case 'comment': $label = 'Comments'; break;
        case 'forum': $label = 'Topics'; break;
        case 'work': $label = 'Work'; break;
        case 'event': $label = 'Events'; break;
      }

      if (in_array($bundle, array('comment', 'forum', 'work', 'event')) || $debug) {
        $content[] = t($label) . ' <span>' . $val . ($debug ? '/' . $stats_contrib_system[$bundle] : '') . '</span>';
        if ($debug) {
          $content[] = '<div class="debug">(' . round($stats_points_contrib[$bundle], 2) . ' contrib + ' . round($stats_points_votes[$bundle], 2) . ' vote points)</div>';
        }
      }
    }
  }

  // Set vars for user and system point sums
  $stats_points_contrib = array_sum($stats_points_contrib) + array_sum($stats_points_votes);
  $stats_points_system = array_sum($stats_points_system);

  // Set user rating %
  $stats_contrib_user['rating'] = (($stats_points_contrib * 100) / $stats_points_system);
  $stats_contrib_user['rating'] = round($stats_contrib_user['rating'], 2) . '%';

  // Add UI item
  if ($debug) {
    array_unshift($content, '<div class="debug">(' . round($stats_points_contrib, 2) . ' of ' . round($stats_points_system, 2) . ' points' . ')</div>');
  }

  array_unshift($content, t('Rating') . ' <span>' . $stats_contrib_user['rating'] . '</span>');


  // Set return markup
  if (!empty($content)) {
    $content = theme_item_list(array(
      'title' => t('Stats:'),
      'type' => 'ul',
      'items' => $content,
      'attributes' => array(
        'class' => array('stats'),
      ),
    )) . '<div class="clearfix"></div>';
  }
  else {
    $content = NULL;
  }

  return $content;
 *
 */
}

// Hook implementations.
/**
 * Implements MODULE_preprocess_region().
 */
function totem_rating_preprocess_page(&$vars) {
  global $user;
  // Adjustments for page--user.tpl.php
  // This is now a block. Assigned to the Preface region by default.
  /* if (in_array('page__user', $vars['theme_hook_suggestions'])) {
    $vars['action_links']['rating'] = array(
      '#type' => 'markup',
      '#markup' => _totem_rating_user_score($user),
    );
  } */
}