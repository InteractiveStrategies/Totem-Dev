<?php
/**
 * @file
 * totem_search.module
 */

// Private helper functions.
/**
 * Helper function to execute a custom search against core index.
 */
function _totem_search_search_index($keys = NULL, $conditions = NULL) {

  $results = array(
    ':entity_id_node' => array(),
    ':entity_id_user' => array(),
  );

  // ////////////////////////////////////////////////////////////////////////
  // BEGIN SHALLOW COPY OF node_search_execute.
  //
  // This version has all paging and node_access stuff removed, and only
  // returns nid values (vs. full node_load per result).
  //
  // Build matching conditions.
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery');
  $query->join('node', 'n', 'n.nid = i.sid');
  $query
    ->fields('n', array('nid'))
    ->condition('n.status', 1)
    /*
     * Omit all access checks for node search results. We want anon+auth users
     * to see the same results. Actual login prompt from search results is
     * handled via totem_user_url_outbound_alter(). If direct access to
     * a result is attempted, totem_user_node_access() takes over and
     * grants/denies as needed.
     *
     * ->addTag('node_access')
     */
    ->searchExpression($keys, 'node');

  // Insert special keywords.
  $query->setOption('type', 'n.type');
  $query->setOption('language', 'n.language');
  if ($query->setOption('term', 'ti.tid')) {
    $query->join('taxonomy_index', 'ti', 'n.nid = ti.nid');
  }

  // Only continue if the first pass query matches.
  if ($query->executeFirstPass()) {
    // Add the ranking expressions.
    _node_rankings($query);

    // Load results.
    $invocation = array(
      'entity_type' => 'node',
      'entity_id' => $query->execute()->fetchCol(),
    );

    $results[':entity_id_node'] = $invocation['entity_id'];
  }

  // END SHALLOW COPY OF node_search_execute.
  // ////////////////////////////////////////////////////////////////////////
  //
  // The core search mod will invoke totem_common_search_execute.
  // Instead of doing a scalar execute of nodes defined by this mod (a standard
  // search mod implementation), we want the hook to instead return ALL search
  // mod's hook_search_execute results and present as a single resultset.
  $modules = module_implements('search_execute');
  $active  = variable_get('search_active_modules');
  $exclude = array(
    // Exclude totem_search to avoid recursion.
    'totem_search',
    // Exclude node because we're using a custom shallow copy of
    // node_search_execute above.
    'node',
    // Exclude user because totem_user is a whole lot better than core.
    'user',
  );

  // Prune list of search mods to invoke.
  foreach ($active as $key => $val) {
    if (empty($val) || !in_array($key, $modules) || in_array($key, $exclude)) {
      unset($active[$key]);
    }
  }

  // Loop modules and invoke hook_search_execute; merge each mod's results to
  // local array.
  //
  // Note: any profile Feature search mod must return array(
  //   'entity_type' => $entity_type,
  //   'entity_id' => $entity_id,
  // );
  $modules = array_keys($active);
  foreach ($modules as $module) {
    $invocation = module_invoke($module, 'search_execute', $keys, $conditions);
    if (array_key_exists('entity_type', $invocation) && array_key_exists('entity_id', $invocation)) {
      $results[':entity_id_' . $invocation['entity_type']] = array_merge(
        $results[':entity_id_' . $invocation['entity_type']],
        $invocation['entity_id']
      );
    }
  }

  return $results;
}

// Hook implementations.
/**
 * Implements hook_modules_enabled().
 */
function totem_search_modules_enabled($modules) {

  // Update the list of node types each time a mod is enabled.
  // Custom search var (search all node types + user entity type).
  $totem_search_search_types = node_type_get_names();
  $totem_search_search_types['totem_user'] = 'Member';
  unset($totem_search_search_types['page']);
  $totem_search_search_types = array_map('check_plain', $totem_search_search_types);

  // Translate type names.
  foreach ($totem_search_search_types as $key => &$val) {
    $val = t($val);
  }

  variable_set('totem_search_search_types', $totem_search_search_types);

}
/**
 * Implements hook_theme_registry_alter().
 */
function totem_search_theme_registry_alter(&$theme_registry) {
  $path = drupal_get_path('module', 'totem_search');
  _totem_common_theme_registry_alter($theme_registry, $path);
}
/**
 * Implements hook_module_implements_alter().
 *
 * Speed of core search is increased by about 30% by removing keyword logging.
 *
 * @see http://drupal.org/node/733054
 * @see search_view()
 * @see totem_search_module_implements_alter()
 */
function totem_search_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'watchdog' || $hook == 'cron') {
    // dblog_watchdog() will be called from our own watchdog implementation
    // when necessary.
    // dblog_cron() is not necessary and it won't work. While install tries to
    // kill it with a variable, better safe than sorry.
    unset($implementations['dblog']);
  }
}
/**
 * Implements hook_watchdog().
 *
 * Speed of core search is increased by about 30% by removing keyword logging.
 *
 * @see http://drupal.org/node/733054
 * @see search_view()
 * @see totem_search_module_implements_alter()
 */
function totem_search_watchdog(array $log_entry) {

  $nolog_entry_types = array('search');

  if (!in_array($log_entry['type'], $nolog_entry_types)) {
    if (module_exists('dblog')) {
      dblog_watchdog($log_entry);
    }
  }
}

// Hook implementations (search + Features mods).
/**
 * Implements hook_search_info().
 */
function totem_search_search_info() {

  $path = variable_get('totem_custom');
  if (empty($path)) {
    $path = variable_get('install_profile');
  }

  return array(
    'title' => variable_get('site_name'),
    'path' => $path,
    'conditions_callback' => 'totem_search_conditions_callback',
  );
}
/**
 * Custom conditions callback to include additional $_GET filter params.
 */
function totem_search_conditions_callback($keys) {

  $conditions = drupal_get_query_parameters();

  return $conditions;
}
/**
 * Implements hook_search_execute().
 */
function totem_search_search_execute($keys = NULL, $conditions = NULL) {

  // Execute aggregated hook_search_execute across all search mods.
  $placeholders = _totem_search_search_index($keys, $conditions);

  // Execute range query.
  $query = _totem_common_entity_range_query(array(
    'entity_type' => array('user', 'node'),
    'placeholders' => $placeholders,
    'limit' => PAGE_SIZE_LISTS_PAGE,
    'order_by' => 'ORDER BY pool.entity_type DESC, pool.title ASC',
  ));

  // Get entity type metadata.
  $types_meta = _totem_common_types_info();

  // Loop and build $results.
  $results = array();
  while ($row = $query['query']->fetchAssoc()) {

    $entity
      = $build
      = $title
      = $author
      = $date
      = $type
      = NULL;

    // Load entity and build a renderable object.
    switch ($row['entity_type']) {
      case 'user':
        $entity = user_load($row['entity_id']);
        $build = user_view($entity, 'search_result');
        $title =
          $author = format_username($entity);
        $date = $entity->created;
        $type = 'user';
        break;

      case 'node':
        $entity = node_load($row['entity_id']);
        $build = node_view($entity, 'search_result');
        $title = $entity->title;
        $author = format_username($entity);
        $date = $entity->changed;
        $type = $entity->type;
        break;
    }

    $uri_entity = entity_uri($row['entity_type'], $entity);
    $uri_author = entity_uri('user', $entity);

    /*
     * TODO: Access checking in effect for anonymous users; displaying
     * referenced field_community data for user entities does not work.
     * Likely has something to do with custom "totem_user_node_search" node
     * grant and inheritance that gets propagated to nodes that belong to a
     * "parent" community node see totem_user_node_access(). There is no grant
     * equivalent for user entities that's possible in core; am guessing we'd
     * need some sort of hackery added to a hook_user_view to accomodate.
     */
    $nid_community = ($type == 'community' ? array($entity->nid) : _totem_common_get_field_entityreference_values($row['entity_type'], $entity, 'field_community'));
    $node_community = NULL;
    if (!empty($nid_community)) {
      $node_community = node_load($nid_community[0]);
      $node_community = node_view($node_community, 'teaser');
    }

    // Get rendered entity for search_excerpt call.
    unset($build['#theme']);
    $entity->rendered = drupal_render($build);

    $results[] = array(
      'link' => l($title, url($uri_entity['path'], array_merge($uri_entity['options'], array('absolute' => TRUE)))),
      'link_uri' => $uri_entity,
      'type' => $type,
      'type_human' => $types_meta[$type]->name,
      'title' => check_plain($title),
      'user' => l($author, url($uri_author['path'], array_merge($uri_author['options'], array('absolute' => TRUE)))),
      'language' => entity_language($row['entity_type'], $entity),
      'snippet' => search_excerpt($keys, $entity->rendered),
      // Have to format date in preprocessor so core's
      // template_preprocess_search_result doesn't choke.
      'date' => $date,
      // Need to attach full pager here so we can use it as override in
      // totem_search_preprocess_search_results.
      'pager' => &$query['pager'],
      // Set first associated community node.
      'community' => $node_community,
    );
  }

  return $results;
}
/**
 * Implements hook_totem_common_EFQ_params_alter().
 */
function totem_search_totem_common_EFQ_params_alter(&$vars, $type) {

  if ($type !== 'search') {
    return FALSE;
  }

  // Get querystring args.
  $args = totem_search_conditions_callback(NULL);
  if (empty($args)) {
    return FALSE;
  }

  // Add EFQ params per keyword pre-filter.
  if (!empty($args['keys'])) {
    // Get keyword results.
    $placeholders = _totem_search_search_index($args['keys']);

    // Add EFQ conditions. Force a SQL clause if any keyword attempt made;
    // Otherwise it looks like we're ignoring search request.
    switch ($vars['entity_type']) {
      case 'node':
        $vars['property_conditions'][] = array('column' => 'nid', 'value' => (!empty($placeholders[':entity_id_node']) ? $placeholders[':entity_id_node'] : '0'));
        break;

      case 'user':
        $vars['property_conditions'][] = array('column' => 'uid', 'value' => (!empty($placeholders[':entity_id_user']) ? $placeholders[':entity_id_user'] : '0'));
        break;
    }
  }

  // Add EFQ params per taxonomy pre-filter.
  if (!empty($args['tags'])) {
    // Get tids per current tag name args.
    $tids = db_select('taxonomy_term_data', 'td')
      ->distinct()
      ->fields('td', array('tid'))
      ->condition('td.name', drupal_explode_tags($args['tags']))
      ->execute()
      ->fetchCol();

    if (!empty($tids)) {
      // Get all fields for this bundle type.
      $fields = field_info_instances($vars['entity_type'], $vars['bundle']);
      if (!empty($fields)) {

        // Copy EFQ params from input args for use in per-field queries below.
        $vars_copy = $vars;
        $entity_id_matches = array();

        // Loop all fields for this bundle type.
        foreach ($fields as $key => $meta) {
          // Make sure this is a taxonomy field.
          if (!empty($meta['display']['default']['module']) && $meta['display']['default']['module'] == 'taxonomy') {

            /*
             * Note: if we wanted a query that did this:
             *   keywords AND (term AND term AND term)
             *
             * ...we could use this addititive field_conditions and be done:
             *   $vars['field_conditions'][] = array('field' => $meta['field_name'], 'column' => 'tid', 'value' => $tids);
             *
             * However, we actually want the terms to use an OR query, as it's
             * way more useful to user:
             *   keywords AND (term OR term OR term)
             *
             * ...so we have to do some smaller queries per taxonomy field,
             * collect the entity_id results in to an outer array, then use
             * that to apply a single property_condition to the caller's EFQ.
             *
             * Considered a $vars['tags'] approach, but I'm not sure that would
             * be remarkably more efficient (or even possible).
             *
             */
            // Query for entity taxonomy matches ONLY for this term field.
            // Merge to outer match array.
            $vars_copy['return'] = 'entity_id';
            $vars_copy['field_conditions'] = array(
              array('field' => $meta['field_name'], 'column' => 'tid', 'value' => $tids),
            );
            $entity_id_matches = array_merge($entity_id_matches, _totem_common_efq($vars_copy)->results);
          }
        }

        // Now we've got a list of entity_id matches per term field.
        // Roll shit up and smoke it in the actual caller EFQ params.
        // Result will effectively be the same as a true, OR query between
        // taxonomy fields.
        if (!empty($entity_id_matches)) {
          // Not sure we care about taxonomy on any entity types.
          // Except node and user.
          switch ($vars['entity_type']) {
            case 'node':
              $vars['property_conditions'][] = array('column' => 'nid', 'value' => $entity_id_matches);
              break;

            case 'user':
              $vars['property_conditions'][] = array('column' => 'uid', 'value' => $entity_id_matches);
              break;
          }
        }

      }
    }
  }

}

// Template preprocessor implementations.
/**
 * Implements template_preprocess_page().
 */
function totem_search_preprocess_page(&$vars) {

  // Add module UI assets.
  if (!$vars['is_admin']) {
    $path = drupal_get_path('module', 'totem_search');

    drupal_add_css($path . '/theme/totem_search.css');

    drupal_add_js($path . '/theme/totem_search.js', array(
      'scope' => 'footer',
    ));
  }

}
/**
 * Implements template_preprocess_search_results().
 */
function totem_search_preprocess_search_results(&$vars) {

  $results = &$vars['results'];

  if (!empty($results)) {

    // Use custom pager instead of core.
    $pager = $results[0]['pager'];
    $vars['pager'] = render($pager);

    // Add JS vars for result metadata.
    drupal_add_js(
      array(
        'totem_search' => array(
          'current_page' => $pager['current_page'],
          'count_pages' => $pager['count_pages'],
          'count_results' => $pager['count_results'],
        ),
      ), 'setting'
    );
  }
}
/**
 * Implements template_preprocess_search_result().
 */
function totem_search_preprocess_search_result(&$vars) {

  $result = &$vars['result'];

  $result['date'] = format_date($result['date'], 'short');

  // Add class to support custom "View more" paging.
  $vars['classes_array'][] = 'pager-entity';
}

// Block stuff.
/**
 * Implements hook_block_view().
 */
function totem_search_block_view($delta = '', $context = '') {
  $callback = '_totem_search_block_view_' . $delta;
  if (function_exists($callback)) {
    return $callback($delta, $context);
  }
}
/**
 * Callback for "Search form" at top of list page block view.
 */
function _totem_search_block_view_search_type($delta, $context) {

  if (user_access('search content')) {
    $type = $context[0];

    $block = array(
      'subject' => t('Filter @label', array('@label' => t($type->name_plural))),
      'content' => drupal_get_form('totem_search_form_search_type', array(
        'entity_type' => $type->type,
      )),
    );

    return $block;
  }
}

// Form implementations.
/**
 * Implements hook_form_FORM_ID_alter().
 */
function totem_search_form_search_block_form_alter(&$form, &$form_state) {

  $form['search_block_form']['#attributes']['class'][] = 'corners';

  // Add advanced search link.
  if (user_access('use advanced search')) {
    $default = search_get_default_module_info();

    // Add dropdown of all searchable entity types.
    $form['type'] = array(
      '#type' => 'select',
      '#title' => t('Only of the type(s)'),
      '#title_display' => 'invisible',
      '#options' => variable_get('totem_search_search_types'),
      '#empty_option' => t('entire site'),
      '#empty_value' => '',
      '#weight' => 0,
    );

    $form['search_block_form']['#title'] = t('keyword');
    $form['search_block_form']['#weight'] = 1;
    $form['actions']['#weight'] = 2;

    // Add link to advanced search form.
    $form['tools'] = array(
      '#type' => 'markup',
      '#markup' => l(t('Advanced search'), "search/{$default['path']}", array(
        // Drupal will autoexpand fieldsets if a contained element id is found in the URL hash.
        // @see collapse.js
        'fragment' => 'edit-or',
        'attributes' => array('class' => array('advanced')),
      )),
      '#weight' => 3,
      '#prefix' => '<div class="form-item advanced-wrapper">',
      '#suffix' => '</div>',
    );
  }

  // Substitute search_box_form_submit with custom handler.
  $form['#submit'] = array('totem_search_form_search_block_form_submit');

}
/**
 * Custom submit handler for basic search_box searches.
 */
function totem_search_form_search_block_form_submit($form, &$form_state) {

  if (isset($_GET['destination'])) {
    unset($_GET['destination']);
  }

  $form_id = $form['form_id']['#value'];
  $info = search_get_default_module_info();
  if ($info) {

    $keys = array();

    if (!empty($form_state['values']['type'])) {
      $keys[] = 'type:' . $form_state['values']['type'];
    }
    if (!empty($form_state['values']['search_block_form'])) {
      $keys[] = trim($form_state['values']['search_block_form']);
    }

    if (!empty($keys)) {
      $keys = implode(' ', $keys);
      $form_state['redirect'] = 'search/' . $info['path'] . '/' . $keys;
    }
    else {
      form_set_error('keys', t('Please enter some keywords.'));
    }
  }
  else {
    form_set_error(NULL, t('Search is currently disabled.'), 'error');
  }
}
/**
 * Implements hook_form_FORM_ID_alter().
 */
function totem_search_form_search_form_alter(&$form, $form_state) {

  $search_executed = (!empty($form['basic']['keys']['#default_value']));

  if ($search_executed) {
    $form['basic']['#prefix'] = '<div class="container-inline"><p>' . t('Your search for') . '</p></div>';
    $form['basic']['#suffix'] = '<div class="container-inline"><p>' . t('generated <span class="meta-count-results">0</span> results') . '</p></div>';
  }
  else {
    $form['basic']['#prefix'] = '<div class="container-inline"><p>' . $form['basic']['keys']['#title'] . '</p></div>';
  }

  $form['basic']['keys']['#title_display']           = 'invisible';
  $form['basic']['submit']['#prefix']                = '<div class="form-actions form-wrapper">';
  $form['basic']['submit']['#suffix']                = '</div>';
  $form['basic']['submit']['#attributes']['class'][] = 'btn';
  $form['basic']['submit']['#attributes']['class'][] = 'corners';


  if (isset($form['module']) && $form['module']['#value'] == 'totem_search' && user_access('use advanced search')) {

    $form['#validate'][] = 'node_search_validate';

    $form['advanced'] = array(
      '#type' => 'fieldset',
      '#title' => t('Advanced search'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('class' => array('search-advanced')),
      '#prefix' => '<div class="clearfix"></div>',
    );

    $form['advanced']['keywords'] = array(
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
    );

    $form['advanced']['keywords']['or'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing any of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    $form['advanced']['keywords']['phrase'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing the phrase'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    $form['advanced']['keywords']['negative'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing none of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    $form['advanced']['type'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Only of the type(s)'),
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
      '#options' => variable_get('totem_search_search_types'),
    );

    $form['advanced']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Search'),
      '#prefix' => '<div class="action">',
      '#suffix' => '</div>',
      '#attributes' => array('class' => array('btn', 'corners')),
      '#weight' => 100,
    );

    $language_options = array();
    foreach (language_list('language') as $key => $entity) {
      if ($entity->enabled) {
        $language_options[$key] = $entity->name;
      }
    }
    if (count($language_options) > 1) {
      $form['advanced']['language'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Languages'),
        '#prefix' => '<div class="criterion">',
        '#suffix' => '</div>',
        '#options' => $language_options,
      );
    }

  }
}
/**
 * Custom form for keywords + tags searches.
 */
function totem_search_form_search_type($form, $form_state) {

  $args = $form_state['build_info']['args'][0];
  $args = array_merge($args, drupal_get_query_parameters());

  $form = array(
    '#submit' => array('totem_search_form_search_type_submit'),
    '#attributes' => array('class' => array('container-inline', 'clearfix')),
  );

  $form['keys'] = array(
    '#type' => 'textfield',
    '#title' => t('keywords'),
    '#title_display' => 'invisible',
    '#maxlength' => 128,
    '#default_value' => (!empty($args['keys']) ? $args['keys'] : NULL),
  );

  $form['tags'] = array(
    '#type' => 'textfield',
    '#title' => t('subject area'),
    '#title_display' => 'invisible',
    '#maxlength' => 128,
    '#default_value' => (!empty($args['tags']) ? $args['tags'] : NULL),
    '#autocomplete_path' => 'totem_common/autocomplete/taxonomy/' . $args['entity_type'],
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
    '#attributes' => array(
      'class' => array('btn', 'corners'),
    ),
  );

  return $form;
}
/**
 * Submit handler for custom keywords + tags form.
 */
function totem_search_form_search_type_submit($form, &$form_state) {

  $args['keys'] = $form_state['values']['keys'];
  $args['tags'] = $form_state['values']['tags'];

  $form_state['redirect'] = array(drupal_get_path_alias(), array('query' => $args));
  drupal_redirect_form($form_state);
}
